"use strict";(self.webpackChunkdip_docs=self.webpackChunkdip_docs||[]).push([[1826],{4061:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>y,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"esp/royalties","title":"Royalties","description":"The ESP royalty system provides economic incentives for data publishers by allowing them to earn royalties when developers re-register the same data on-chain. This creates a self-sustaining economic model that rewards data creators for preventing duplicate uploads and ensures the protocol\'s long-term viability.","source":"@site/docs/02-esp/05-royalties.md","sourceDirName":"02-esp","slug":"/esp/royalties","permalink":"/docs/esp/royalties","draft":false,"unlisted":false,"editUrl":"https://github.com/TechnicallyWeb3/dip-docs/tree/main/packages/create-docusaurus/templates/shared/docs/02-esp/05-royalties.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"royalties","title":"Royalties"},"sidebar":"tutorialSidebar","previous":{"title":"Registry","permalink":"/docs/esp/registry"},"next":{"title":"WTTP Overview","permalink":"/docs/wttp/wttp-overview"}}');var s=a(4848),r=a(8453);const i={id:"royalties",title:"Royalties"},o="ESP Royalty System",l={},c=[{value:"Overview",id:"overview",level:2},{value:"How Royalties Work",id:"how-royalties-work",level:2},{value:"Royalty Calculation",id:"royalty-calculation",level:3},{value:"Royalty Distribution",id:"royalty-distribution",level:3},{value:"Core Functions",id:"core-functions",level:2},{value:"<code>getDataPointRoyalty(bytes32 _dataPointAddress)</code>",id:"getdatapointroyaltybytes32-_datapointaddress",level:3},{value:"<code>collectRoyalties(uint256 _amount, address _withdrawTo)</code>",id:"collectroyaltiesuint256-_amount-address-_withdrawto",level:3},{value:"<code>royaltyBalance(address _publisher)</code>",id:"royaltybalanceaddress-_publisher",level:3},{value:"Royalty Lifecycle",id:"royalty-lifecycle",level:2},{value:"1. Data Registration",id:"1-data-registration",level:3},{value:"2. Data Re-registration",id:"2-data-re-registration",level:3},{value:"3. Royalty Collection",id:"3-royalty-collection",level:3},{value:"Royalty-Free Data",id:"royalty-free-data",level:2},{value:"Waiving Royalties",id:"waiving-royalties",level:3},{value:"Use Cases for Royalty-Free Data",id:"use-cases-for-royalty-free-data",level:3},{value:"Advanced Royalty Management",id:"advanced-royalty-management",level:2},{value:"Batch Royalty Collection",id:"batch-royalty-collection",level:3},{value:"Royalty Analytics",id:"royalty-analytics",level:3},{value:"Conditional Royalty Payment",id:"conditional-royalty-payment",level:3},{value:"Economic Model",id:"economic-model",level:2},{value:"Incentive Structure",id:"incentive-structure",level:3},{value:"Economic Parameters",id:"economic-parameters",level:3},{value:"Gas-Based Royalty Calculation",id:"gas-based-royalty-calculation",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"With DApps",id:"with-dapps",level:3},{value:"With Smart Contracts",id:"with-smart-contracts",level:3},{value:"With Frontend Applications",id:"with-frontend-applications",level:3},{value:"Monitoring and Analytics",id:"monitoring-and-analytics",level:2},{value:"Event Monitoring",id:"event-monitoring",level:3},{value:"Royalty Analytics",id:"royalty-analytics-1",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Gas Optimization",id:"gas-optimization",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Insufficient Royalty Payment",id:"insufficient-royalty-payment",level:4},{value:"Royalty Collection Failures",id:"royalty-collection-failures",level:4},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"esp-royalty-system",children:"ESP Royalty System"})}),"\n",(0,s.jsx)(t.p,{children:"The ESP royalty system provides economic incentives for data publishers by allowing them to earn royalties when developers re-register the same data on-chain. This creates a self-sustaining economic model that rewards data creators for preventing duplicate uploads and ensures the protocol's long-term viability."}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"The royalty system works through a two-phase process:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Registration Phase"}),": Publishers register data and pay gas costs, earning the right to collect royalties"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Re-registration Phase"}),": Developers pay royalties when they want to re-register the same data on-chain, with publishers receiving the majority of the payment"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"how-royalties-work",children:"How Royalties Work"}),"\n",(0,s.jsx)(t.h3,{id:"royalty-calculation",children:"Royalty Calculation"}),"\n",(0,s.jsx)(t.p,{children:"Royalties are calculated based on gas usage during the initial data storage:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"royalty_amount = gas_used \xd7 royalty_rate\n"})}),"\n",(0,s.jsx)(t.p,{children:"Where:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"gas_used"}),": Gas consumed during ",(0,s.jsx)(t.code,{children:"writeDataPoint"})," operation"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"royalty_rate"}),": Configurable rate set by the protocol owner"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"royalty-distribution",children:"Royalty Distribution"}),"\n",(0,s.jsx)(t.p,{children:"When royalties are paid:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Publisher"}),": Receives ",(0,s.jsx)(t.code,{children:"royalty_amount - protocol_fee"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Protocol"}),": Receives ",(0,s.jsx)(t.code,{children:"royalty_amount / 10"})," (10% fee)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Publisher"}),": Receives ",(0,s.jsx)(t.code,{children:"royalty_amount * 9 / 10"})," (90% of royalties)"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,s.jsx)(t.h3,{id:"getdatapointroyaltybytes32-_datapointaddress",children:(0,s.jsx)(t.code,{children:"getDataPointRoyalty(bytes32 _dataPointAddress)"})}),"\n",(0,s.jsx)(t.p,{children:"Gets the royalty cost for re-registering a data point."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Get royalty cost\nconst address = await dataPointStorage.calculateAddress(data);\nconst royaltyCost = await dataPointRegistry.getDataPointRoyalty(address);\nconsole.log("Royalty cost:", ethers.formatEther(royaltyCost), "ETH");\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"uint256"})," - Royalty cost in wei"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"collectroyaltiesuint256-_amount-address-_withdrawto",children:(0,s.jsx)(t.code,{children:"collectRoyalties(uint256 _amount, address _withdrawTo)"})}),"\n",(0,s.jsx)(t.p,{children:"Allows publishers to withdraw their earned royalties."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Withdraw royalties\nconst amount = ethers.parseEther("0.1"); // 0.1 ETH\nconst tx = await dataPointRegistry.collectRoyalties(amount, signer.address);\nawait tx.wait();\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"_amount"}),": Amount to withdraw in wei"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"_withdrawTo"}),": Address to send royalties to"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Events:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"RoyaltiesCollected(address indexed publisher, uint256 amount, address indexed withdrawTo)"})}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"royaltybalanceaddress-_publisher",children:(0,s.jsx)(t.code,{children:"royaltyBalance(address _publisher)"})}),"\n",(0,s.jsx)(t.p,{children:"Checks the royalty balance of a publisher."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Check royalty balance\nconst balance = await dataPointRegistry.royaltyBalance(publisherAddress);\nconsole.log("Royalty balance:", ethers.formatEther(balance), "ETH");\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"uint256"})," - Current balance in wei"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"royalty-lifecycle",children:"Royalty Lifecycle"}),"\n",(0,s.jsx)(t.h3,{id:"1-data-registration",children:"1. Data Registration"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Publisher registers data and pays gas\nconst data = ethers.toUtf8Bytes("My valuable content");\nconst publisherAddress = signer.address;\n\n// This will track gas usage and set up royalty collection\nconst tx = await dataPointRegistry.registerDataPoint(data, publisherAddress);\nawait tx.wait();\n\n// Gas usage is automatically tracked and stored\nconsole.log("Data registered with royalty tracking");\n'})}),"\n",(0,s.jsx)(t.h3,{id:"2-data-re-registration",children:"2. Data Re-registration"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Developer wants to re-register the same data and pays royalties\nconst address = await dataPointStorage.calculateAddress(data);\nconst royaltyCost = await dataPointRegistry.getDataPointRoyalty(address);\n\nif (royaltyCost > 0) {\n    // Pay royalties to re-register the same data\n    const tx = await dataPointRegistry.registerDataPoint(data, ethers.ZeroAddress, {\n        value: royaltyCost\n    });\n    await tx.wait();\n    \n    // Publisher earns royalties (minus protocol fee)\n    console.log("Royalties paid:", ethers.formatEther(royaltyCost));\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"3-royalty-collection",children:"3. Royalty Collection"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Publisher withdraws earned royalties\nconst balance = await dataPointRegistry.royaltyBalance(publisherAddress);\nif (balance > 0) {\n    const tx = await dataPointRegistry.collectRoyalties(balance, publisherAddress);\n    await tx.wait();\n    console.log("Royalties collected:", ethers.formatEther(balance));\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"royalty-free-data",children:"Royalty-Free Data"}),"\n",(0,s.jsx)(t.h3,{id:"waiving-royalties",children:"Waiving Royalties"}),"\n",(0,s.jsxs)(t.p,{children:["Publishers can waive royalties by using ",(0,s.jsx)(t.code,{children:"address(0)"})," as the publisher:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Register data without royalties\nconst data = ethers.toUtf8Bytes("Free content");\nconst tx = await dataPointRegistry.registerDataPoint(data, ethers.ZeroAddress);\nawait tx.wait();\n\n// This data can be re-registered without paying royalties\nconsole.log("Data registered without royalties");\n'})}),"\n",(0,s.jsx)(t.h3,{id:"use-cases-for-royalty-free-data",children:"Use Cases for Royalty-Free Data"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Public domain content"}),"\n",(0,s.jsx)(t.li,{children:"Open source documentation"}),"\n",(0,s.jsx)(t.li,{children:"Community resources"}),"\n",(0,s.jsx)(t.li,{children:"Educational materials"}),"\n",(0,s.jsx)(t.li,{children:"Protocol metadata"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"advanced-royalty-management",children:"Advanced Royalty Management"}),"\n",(0,s.jsx)(t.h3,{id:"batch-royalty-collection",children:"Batch Royalty Collection"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Collect royalties for multiple publishers\nasync function collectAllRoyalties(publishers: string[]) {\n    for (const publisher of publishers) {\n        const balance = await dataPointRegistry.royaltyBalance(publisher);\n        if (balance > 0) {\n            const tx = await dataPointRegistry.collectRoyalties(balance, publisher);\n            await tx.wait();\n            console.log(`Collected ${ethers.formatEther(balance)} for ${publisher}`);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"royalty-analytics",children:"Royalty Analytics"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Track royalty earnings over time\nclass RoyaltyTracker {\n    private registry: DataPointRegistry;\n    \n    constructor(registry: DataPointRegistry) {\n        this.registry = registry;\n    }\n    \n    async getPublisherStats(publisher: string) {\n        const balance = await this.registry.royaltyBalance(publisher);\n        return {\n            currentBalance: ethers.formatEther(balance),\n            balanceWei: balance.toString()\n        };\n    }\n    \n    async getTotalRoyaltiesPaid(dataPointAddress: string) {\n        // This would require additional tracking - simplified example\n        const royaltyCost = await this.registry.getDataPointRoyalty(dataPointAddress);\n        return ethers.formatEther(royaltyCost);\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"conditional-royalty-payment",children:"Conditional Royalty Payment"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Pay royalties only if data exists and has royalties\nasync function accessDataWithRoyalties(data: Uint8Array) {\n    const address = await dataPointStorage.calculateAddress(data);\n    const royaltyCost = await dataPointRegistry.getDataPointRoyalty(address);\n    \n    if (royaltyCost > 0) {\n        // Data exists and has royalties\n        const tx = await dataPointRegistry.registerDataPoint(data, ethers.ZeroAddress, {\n            value: royaltyCost\n        });\n        await tx.wait();\n        console.log("Royalties paid:", ethers.formatEther(royaltyCost));\n    } else {\n        // Data doesn\'t exist or has no royalties\n        const tx = await dataPointRegistry.registerDataPoint(data, ethers.ZeroAddress);\n        await tx.wait();\n        console.log("No royalties required");\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"economic-model",children:"Economic Model"}),"\n",(0,s.jsx)(t.h3,{id:"incentive-structure",children:"Incentive Structure"}),"\n",(0,s.jsx)(t.p,{children:"The royalty system creates several incentives:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Data Quality"}),": Publishers are incentivized to create valuable content"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Data Availability"}),": Publishers maintain access to their data"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Protocol Sustainability"}),": Protocol fees support ongoing development"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Fair Compensation"}),": Publishers receive 90% of royalty payments"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"economic-parameters",children:"Economic Parameters"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Protocol parameters\nconst PROTOCOL_FEE_RATE = 0.1; // 10%\nconst PUBLISHER_SHARE = 0.9;   // 90%\n\n// Royalty calculation\nfunction calculateRoyaltyDistribution(royaltyAmount: bigint) {\n    const protocolFee = royaltyAmount / 10n;\n    const publisherShare = royaltyAmount - protocolFee;\n    \n    return {\n        protocolFee,\n        publisherShare,\n        total: royaltyAmount\n    };\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"gas-based-royalty-calculation",children:"Gas-Based Royalty Calculation"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Royalty is based on gas usage during storage\nasync function estimateRoyaltyCost(data: Uint8Array, royaltyRate: bigint) {\n    // Estimate gas for writeDataPoint\n    const gasEstimate = await dataPointStorage.writeDataPoint.estimateGas(data);\n    \n    // Calculate royalty cost\n    const royaltyCost = gasEstimate * royaltyRate;\n    \n    return {\n        gasEstimate: gasEstimate.toString(),\n        royaltyCost: ethers.formatEther(royaltyCost),\n        royaltyCostWei: royaltyCost.toString()\n    };\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(t.h3,{id:"with-dapps",children:"With DApps"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// DApp integration for content monetization\nclass ContentDApp {\n    private registry: DataPointRegistry;\n    private storage: DataPointStorage;\n    \n    constructor(registry: DataPointRegistry, storage: DataPointStorage) {\n        this.registry = registry;\n        this.storage = storage;\n    }\n    \n    async publishContent(content: string, publisher: string) {\n        const data = ethers.toUtf8Bytes(content);\n        const tx = await this.registry.registerDataPoint(data, publisher);\n        await tx.wait();\n        \n        const address = await this.storage.calculateAddress(data);\n        return {\n            address,\n            txHash: tx.hash,\n            publisher\n        };\n    }\n    \n    async reRegisterContent(data: Uint8Array, developerAddress: string) {\n        const address = await this.storage.calculateAddress(data);\n        const royaltyCost = await this.registry.getDataPointRoyalty(address);\n        \n        if (royaltyCost > 0) {\n            // Developer pays royalties to re-register\n            const tx = await this.registry.registerDataPoint(\n                data,\n                ethers.ZeroAddress,\n                { value: royaltyCost }\n            );\n            await tx.wait();\n        }\n        \n        return address;\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"with-smart-contracts",children:"With Smart Contracts"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"// Solidity contract for royalty management\ncontract RoyaltyManager {\n    IDataPointRegistry public registry;\n    \n    constructor(address _registry) {\n        registry = IDataPointRegistry(_registry);\n    }\n    \n    function publishWithRoyalties(bytes memory data, address publisher) external {\n        registry.registerDataPoint(data, publisher);\n    }\n    \n    function reRegisterWithRoyalties(bytes memory data) external payable {\n        registry.registerDataPoint{value: msg.value}(data, address(0));\n    }\n    \n    function collectRoyalties(uint256 amount) external {\n        registry.collectRoyalties(amount, msg.sender);\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"with-frontend-applications",children:"With Frontend Applications"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// React component for royalty management\nimport { useState, useEffect } from 'react';\n\nfunction RoyaltyDashboard({ registry, publisherAddress }) {\n    const [balance, setBalance] = useState('0');\n    const [loading, setLoading] = useState(false);\n    \n    useEffect(() => {\n        loadBalance();\n    }, [publisherAddress]);\n    \n    const loadBalance = async () => {\n        const balance = await registry.royaltyBalance(publisherAddress);\n        setBalance(ethers.formatEther(balance));\n    };\n    \n    const collectRoyalties = async () => {\n        setLoading(true);\n        try {\n            const balance = await registry.royaltyBalance(publisherAddress);\n            if (balance > 0) {\n                const tx = await registry.collectRoyalties(balance, publisherAddress);\n                await tx.wait();\n                await loadBalance();\n            }\n        } catch (error) {\n            console.error(\"Failed to collect royalties:\", error);\n        } finally {\n            setLoading(false);\n        }\n    };\n    \n    return (\n        <div>\n            <h3>Royalty Balance: {balance} ETH</h3>\n            <button \n                onClick={collectRoyalties} \n                disabled={loading || balance === '0.0'}\n            >\n                {loading ? 'Collecting...' : 'Collect Royalties'}\n            </button>\n        </div>\n    );\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"monitoring-and-analytics",children:"Monitoring and Analytics"}),"\n",(0,s.jsx)(t.h3,{id:"event-monitoring",children:"Event Monitoring"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Monitor royalty events\nconst royaltyPaidFilter = dataPointRegistry.filters.RoyaltiesPaid();\ndataPointRegistry.on(royaltyPaidFilter, (dataPointAddress, payer, amount) => {\n    console.log("Royalty paid:", {\n        dataPoint: dataPointAddress,\n        payer: payer,\n        amount: ethers.formatEther(amount)\n    });\n});\n\nconst royaltyCollectedFilter = dataPointRegistry.filters.RoyaltiesCollected();\ndataPointRegistry.on(royaltyCollectedFilter, (publisher, amount, withdrawTo) => {\n    console.log("Royalty collected:", {\n        publisher: publisher,\n        amount: ethers.formatEther(amount),\n        withdrawTo: withdrawTo\n    });\n});\n'})}),"\n",(0,s.jsx)(t.h3,{id:"royalty-analytics-1",children:"Royalty Analytics"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Track royalty performance\nclass RoyaltyAnalytics {\n    private registry: DataPointRegistry;\n    \n    constructor(registry: DataPointRegistry) {\n        this.registry = registry;\n    }\n    \n    async getPublisherPerformance(publisher: string) {\n        const balance = await this.registry.royaltyBalance(publisher);\n        return {\n            currentBalance: ethers.formatEther(balance),\n            balanceWei: balance.toString()\n        };\n    }\n    \n    async getDataPointRoyaltyInfo(dataPointAddress: string) {\n        const royaltyCost = await this.registry.getDataPointRoyalty(dataPointAddress);\n        return {\n            royaltyCost: ethers.formatEther(royaltyCost),\n            royaltyCostWei: royaltyCost.toString()\n        };\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(t.h3,{id:"gas-optimization",children:"Gas Optimization"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Optimize gas usage for royalty calculations\nasync function registerDataOptimally(data: Uint8Array, publisher: string) {\n    // Use appropriate gas limits\n    const gasEstimate = await dataPointRegistry.registerDataPoint.estimateGas(data, publisher);\n    const tx = await dataPointRegistry.registerDataPoint(data, publisher, {\n        gasLimit: gasEstimate.mul(120).div(100) // 20% buffer\n    });\n    await tx.wait();\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Comprehensive error handling for royalty operations\nasync function handleRoyaltyPayment(data: Uint8Array) {\n    try {\n        const address = await dataPointStorage.calculateAddress(data);\n        const royaltyCost = await dataPointRegistry.getDataPointRoyalty(address);\n        \n        if (royaltyCost > 0) {\n            const balance = await provider.getBalance(signer.address);\n            if (balance < royaltyCost) {\n                throw new Error("Insufficient balance for royalty payment");\n            }\n            \n            const tx = await dataPointRegistry.registerDataPoint(data, ethers.ZeroAddress, {\n                value: royaltyCost\n            });\n            await tx.wait();\n        }\n    } catch (error) {\n        console.error("Royalty payment failed:", error);\n        throw error;\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Validate royalty payments\nfunction validateRoyaltyPayment(amount: bigint, expectedCost: bigint): boolean {\n    if (amount < expectedCost) {\n        throw new Error("Insufficient royalty payment");\n    }\n    if (amount > expectedCost * 2n) {\n        console.warn("Royalty payment significantly higher than expected");\n    }\n    return true;\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,s.jsx)(t.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsx)(t.h4,{id:"insufficient-royalty-payment",children:"Insufficient Royalty Payment"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Check royalty cost before payment\nconst royaltyCost = await dataPointRegistry.getDataPointRoyalty(address);\nconst balance = await provider.getBalance(signer.address);\n\nif (balance < royaltyCost) {\n    throw new Error(`Insufficient balance. Need ${ethers.formatEther(royaltyCost)} ETH`);\n}\n"})}),"\n",(0,s.jsx)(t.h4,{id:"royalty-collection-failures",children:"Royalty Collection Failures"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Check balance before collection\nconst balance = await dataPointRegistry.royaltyBalance(publisherAddress);\nif (balance === 0n) {\n    console.log("No royalties to collect");\n    return;\n}\n\n// Collect with proper error handling\ntry {\n    const tx = await dataPointRegistry.collectRoyalties(balance, publisherAddress);\n    await tx.wait();\n} catch (error) {\n    console.error("Royalty collection failed:", error);\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/docs/esp/esp-overview",children:"Back to Overview"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/docs/esp/registry",children:"Learn about Registry Operations"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/docs/esp/esp-storage",children:"Explore Storage Layer"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/docs/esp/datapoints",children:"Understand Data Points"})}),"\n"]})]})}function y(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>o});var n=a(6540);const s={},r=n.createContext(s);function i(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);