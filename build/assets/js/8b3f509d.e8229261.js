"use strict";(self.webpackChunkdip_docs=self.webpackChunkdip_docs||[]).push([[5538],{1872:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"esp/esp-storage","title":"ESP Storage","description":"The DataPointStorage contract is the core storage layer of ESP, providing immutable, content-addressed storage for data points. It handles the fundamental operations of storing and retrieving data with cryptographic integrity guarantees.","source":"@site/docs/02-esp/03-storage.md","sourceDirName":"02-esp","slug":"/esp/esp-storage","permalink":"/docs/esp/esp-storage","draft":false,"unlisted":false,"editUrl":"https://github.com/TechnicallyWeb3/dip-docs/tree/main/packages/create-docusaurus/templates/shared/docs/02-esp/03-storage.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"esp-storage","title":"ESP Storage"},"sidebar":"tutorialSidebar","previous":{"title":"DataPoints","permalink":"/docs/esp/datapoints"},"next":{"title":"Registry","permalink":"/docs/esp/registry"}}');var s=a(4848),i=a(8453);const r={id:"esp-storage",title:"ESP Storage"},d="ESP Storage Layer",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Data Size Limits",id:"data-size-limits",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"<code>writeDataPoint(bytes memory _data)</code>",id:"writedatapointbytes-memory-_data",level:3},{value:"<code>readDataPoint(bytes32 _dataPointAddress)</code>",id:"readdatapointbytes32-_datapointaddress",level:3},{value:"<code>calculateAddress(bytes memory _data)</code>",id:"calculateaddressbytes-memory-_data",level:3},{value:"<code>dataPointSize(bytes32 _dataPointAddress)</code>",id:"datapointsizebytes32-_datapointaddress",level:3},{value:"Storage Architecture",id:"storage-architecture",level:2},{value:"Content Addressing",id:"content-addressing",level:3},{value:"Version System",id:"version-system",level:3},{value:"Storage Mapping",id:"storage-mapping",level:3},{value:"Usage Patterns",id:"usage-patterns",level:2},{value:"Basic Storage and Retrieval",id:"basic-storage-and-retrieval",level:3},{value:"Data Existence Checking",id:"data-existence-checking",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Common Errors",id:"common-errors",level:3},{value:"<code>InvalidData()</code>",id:"invaliddata",level:4},{value:"<code>DataExists(bytes32 dataPointAddress)</code>",id:"dataexistsbytes32-datapointaddress",level:4},{value:"Error Prevention",id:"error-prevention",level:3},{value:"Gas Optimization",id:"gas-optimization",level:2},{value:"Gas Estimation",id:"gas-estimation",level:3},{value:"Gas Optimization Tips",id:"gas-optimization-tips",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"With DataPointRegistry",id:"with-datapointregistry",level:3},{value:"With Frontend Applications",id:"with-frontend-applications",level:3},{value:"With Smart Contracts",id:"with-smart-contracts",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Immutability",id:"immutability",level:3},{value:"Access Control",id:"access-control",level:3},{value:"Data Integrity",id:"data-integrity",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Storage Efficiency",id:"storage-efficiency",level:3},{value:"Gas Costs",id:"gas-costs",level:3},{value:"Scalability",id:"scalability",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Data Size Considerations",id:"data-size-considerations",level:3},{value:"Error Handling",id:"error-handling-1",level:3},{value:"Monitoring",id:"monitoring",level:3},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"esp-storage-layer",children:"ESP Storage Layer"})}),"\n",(0,s.jsx)(t.p,{children:"The DataPointStorage contract is the core storage layer of ESP, providing immutable, content-addressed storage for data points. It handles the fundamental operations of storing and retrieving data with cryptographic integrity guarantees."}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"The DataPointStorage contract is designed to be:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Immutable"}),": Once stored, data cannot be modified"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Content-addressed"}),": Data is identified by its content hash"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Collision-resistant"}),": Different data produces different addresses"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Gas-efficient"}),": Optimized for cost-effective storage operations"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"data-size-limits",children:"Data Size Limits"}),"\n",(0,s.jsx)(t.p,{children:"ESP has practical limits on data point size:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Recommended maximum"}),": 32KB per data point"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Absolute maximum"}),": ~42KB (tested limit)"]}),"\n",(0,s.jsx)(t.li,{children:"For larger data, build custom smart contracts that chunk data into ESP-compatible sizes"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,s.jsx)(t.h3,{id:"writedatapointbytes-memory-_data",children:(0,s.jsx)(t.code,{children:"writeDataPoint(bytes memory _data)"})}),"\n",(0,s.jsx)(t.p,{children:"Stores a new data point and returns its address."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Store data\nconst data = ethers.toUtf8Bytes("Hello, ESP!");\nconst tx = await dataPointStorage.writeDataPoint(data);\nawait tx.wait();\n\n// Get the address where data was stored\nconst address = await dataPointStorage.calculateAddress(data);\nconsole.log("Data stored at:", address);\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Requirements:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Data cannot be empty"}),"\n",(0,s.jsx)(t.li,{children:"Address must not already be occupied"}),"\n",(0,s.jsx)(t.li,{children:"Returns the storage address"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Events:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"DataPointWritten(bytes32 indexed dataPointAddress)"})}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"readdatapointbytes32-_datapointaddress",children:(0,s.jsx)(t.code,{children:"readDataPoint(bytes32 _dataPointAddress)"})}),"\n",(0,s.jsx)(t.p,{children:"Retrieves stored data by its address."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Read data\nconst data = await dataPointStorage.readDataPoint(address);\nconsole.log("Retrieved data:", ethers.toUtf8String(data));\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"bytes memory"})," - The stored data"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"calculateaddressbytes-memory-_data",children:(0,s.jsx)(t.code,{children:"calculateAddress(bytes memory _data)"})}),"\n",(0,s.jsx)(t.p,{children:"Calculates the storage address for given data."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Calculate address before storing\nconst data = ethers.toUtf8Bytes("My data");\nconst address = await dataPointStorage.calculateAddress(data);\nconsole.log("Will be stored at:", address);\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"bytes32"})," - The calculated address"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"datapointsizebytes32-_datapointaddress",children:(0,s.jsx)(t.code,{children:"dataPointSize(bytes32 _dataPointAddress)"})}),"\n",(0,s.jsx)(t.p,{children:"Returns the size of stored data."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Check data size\nconst size = await dataPointStorage.dataPointSize(address);\nconsole.log("Data size:", size, "bytes");\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"uint256"})," - Size in bytes (0 if data doesn't exist)"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"storage-architecture",children:"Storage Architecture"}),"\n",(0,s.jsx)(t.h3,{id:"content-addressing",children:"Content Addressing"}),"\n",(0,s.jsx)(t.p,{children:"Data is stored using content-addressed addressing:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"function calculateDataPointAddress(\n    bytes memory _data,\n    uint8 _version\n) pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_data, _version));\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"version-system",children:"Version System"}),"\n",(0,s.jsx)(t.p,{children:"ESP uses versioning to handle protocol updates:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Current version: 2"}),"\n",(0,s.jsx)(t.li,{children:"Version is included in address calculation"}),"\n",(0,s.jsx)(t.li,{children:"Enables protocol evolution while maintaining compatibility"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"storage-mapping",children:"Storage Mapping"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"mapping(bytes32 => bytes) private dataPointData;\n"})}),"\n",(0,s.jsx)(t.p,{children:"Data is stored in a simple mapping from address to data bytes."}),"\n",(0,s.jsx)(t.h2,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,s.jsx)(t.h3,{id:"basic-storage-and-retrieval",children:"Basic Storage and Retrieval"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'import { DataPointStorage__factory } from \'ethereum-storage\';\n\n// Connect to contract\nconst dataPointStorage = DataPointStorage__factory.connect(\n    contractAddress, \n    signer\n);\n\n// Store data\nconst data = ethers.toUtf8Bytes("Important information");\nconst tx = await dataPointStorage.writeDataPoint(data);\nawait tx.wait();\n\n// Retrieve data\nconst address = await dataPointStorage.calculateAddress(data);\nconst retrievedData = await dataPointStorage.readDataPoint(address);\nconsole.log("Data:", ethers.toUtf8String(retrievedData));\n'})}),"\n",(0,s.jsx)(t.h3,{id:"data-existence-checking",children:"Data Existence Checking"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Check if data exists\nconst address = await dataPointStorage.calculateAddress(data);\nconst size = await dataPointStorage.dataPointSize(address);\n\nif (size > 0) {\n    console.log("Data exists, size:", size.toString());\n    const data = await dataPointStorage.readDataPoint(address);\n} else {\n    console.log("Data does not exist");\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Store multiple data points\nconst dataPoints = [\n    ethers.toUtf8Bytes("Data 1"),\n    ethers.toUtf8Bytes("Data 2"),\n    ethers.toUtf8Bytes("Data 3")\n];\n\nconst addresses = [];\nfor (const data of dataPoints) {\n    const tx = await dataPointStorage.writeDataPoint(data);\n    await tx.wait();\n    const address = await dataPointStorage.calculateAddress(data);\n    addresses.push(address);\n}\n\nconsole.log("Stored addresses:", addresses);\n'})}),"\n",(0,s.jsx)(t.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(t.h3,{id:"common-errors",children:"Common Errors"}),"\n",(0,s.jsx)(t.h4,{id:"invaliddata",children:(0,s.jsx)(t.code,{children:"InvalidData()"})}),"\n",(0,s.jsx)(t.p,{children:"Thrown when trying to store empty data."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'try {\n    const tx = await dataPointStorage.writeDataPoint(ethers.toUtf8Bytes(""));\n} catch (error) {\n    if (error.message.includes("InvalidData")) {\n        console.log("Cannot store empty data");\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"dataexistsbytes32-datapointaddress",children:(0,s.jsx)(t.code,{children:"DataExists(bytes32 dataPointAddress)"})}),"\n",(0,s.jsx)(t.p,{children:"Thrown when trying to store data at an already occupied address."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'try {\n    const tx = await dataPointStorage.writeDataPoint(data);\n} catch (error) {\n    if (error.message.includes("DataExists")) {\n        console.log("Data already exists at this address");\n        // Handle duplicate data\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"error-prevention",children:"Error Prevention"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Check data validity before storing\nfunction validateData(data: Uint8Array): boolean {\n    if (data.length === 0) {\n        throw new Error("Data cannot be empty");\n    }\n    return true;\n}\n\n// Check if data already exists\nasync function safeStoreData(data: Uint8Array) {\n    validateData(data);\n    \n    const address = await dataPointStorage.calculateAddress(data);\n    const size = await dataPointStorage.dataPointSize(address);\n    \n    if (size > 0) {\n        console.log("Data already exists at:", address);\n        return address;\n    }\n    \n    const tx = await dataPointStorage.writeDataPoint(data);\n    await tx.wait();\n    return address;\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"gas-optimization",children:"Gas Optimization"}),"\n",(0,s.jsx)(t.h3,{id:"gas-estimation",children:"Gas Estimation"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Estimate gas before transaction\nconst data = ethers.toUtf8Bytes("My data");\nconst gasEstimate = await dataPointStorage.writeDataPoint.estimateGas(data);\nconsole.log("Estimated gas:", gasEstimate.toString());\n\n// Use gas estimate with buffer\nconst tx = await dataPointStorage.writeDataPoint(data, {\n    gasLimit: gasEstimate.mul(120).div(100) // 20% buffer\n});\n'})}),"\n",(0,s.jsx)(t.h3,{id:"gas-optimization-tips",children:"Gas Optimization Tips"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Use appropriate gas limits"}),"\n",(0,s.jsx)(t.li,{children:"Batch operations when possible"}),"\n",(0,s.jsx)(t.li,{children:"Consider data size impact on gas costs"}),"\n",(0,s.jsx)(t.li,{children:"Use gas estimation for accurate pricing"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(t.h3,{id:"with-datapointregistry",children:"With DataPointRegistry"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Storage is typically used through the registry\nconst data = ethers.toUtf8Bytes("My data");\nconst tx = await dataPointRegistry.registerDataPoint(data, publisherAddress);\nawait tx.wait();\n\n// Registry handles storage internally\n// You can still access storage directly if needed\nconst address = await dataPointStorage.calculateAddress(data);\nconst storedData = await dataPointStorage.readDataPoint(address);\n'})}),"\n",(0,s.jsx)(t.h3,{id:"with-frontend-applications",children:"With Frontend Applications"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// React component example\nimport { useState, useEffect } from 'react';\nimport { DataPointStorage__factory } from 'ethereum-storage';\n\nfunction DataViewer({ contractAddress, dataAddress }) {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n        async function loadData() {\n            try {\n                const storage = DataPointStorage__factory.connect(\n                    contractAddress, \n                    provider\n                );\n                const data = await storage.readDataPoint(dataAddress);\n                setData(ethers.toUtf8String(data));\n            } catch (error) {\n                console.error(\"Failed to load data:\", error);\n            } finally {\n                setLoading(false);\n            }\n        }\n        \n        loadData();\n    }, [contractAddress, dataAddress]);\n\n    if (loading) return <div>Loading...</div>;\n    if (!data) return <div>Data not found</div>;\n    \n    return <div>{data}</div>;\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"with-smart-contracts",children:"With Smart Contracts"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"// Solidity contract using ESP storage\ncontract MyContract {\n    IDataPointStorage public storage;\n    \n    constructor(address _storage) {\n        storage = IDataPointStorage(_storage);\n    }\n    \n    function storeData(bytes memory data) external {\n        storage.writeDataPoint(data);\n    }\n    \n    function getData(bytes32 address) external view returns (bytes memory) {\n        return storage.readDataPoint(address);\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(t.h3,{id:"immutability",children:"Immutability"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Data cannot be modified once stored"}),"\n",(0,s.jsx)(t.li,{children:"Content addressing prevents tampering"}),"\n",(0,s.jsx)(t.li,{children:"Cryptographic integrity is guaranteed"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"access-control",children:"Access Control"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Storage contract has no access restrictions"}),"\n",(0,s.jsx)(t.li,{children:"All functions are public"}),"\n",(0,s.jsx)(t.li,{children:"Access control is handled at the registry level"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"data-integrity",children:"Data Integrity"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Content addressing ensures data integrity"}),"\n",(0,s.jsx)(t.li,{children:"Hash collisions are computationally infeasible"}),"\n",(0,s.jsx)(t.li,{children:"Version system prevents address conflicts"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(t.h3,{id:"storage-efficiency",children:"Storage Efficiency"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Direct mapping storage (O(1) access)"}),"\n",(0,s.jsx)(t.li,{children:"No complex data structures"}),"\n",(0,s.jsx)(t.li,{children:"Minimal overhead per data point"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"gas-costs",children:"Gas Costs"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Storage operations are gas-efficient"}),"\n",(0,s.jsx)(t.li,{children:"Cost scales with data size"}),"\n",(0,s.jsx)(t.li,{children:"No recurring costs for data access"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"scalability",children:"Scalability"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Limited by Ethereum block size"}),"\n",(0,s.jsx)(t.li,{children:"Large data should be stored off-chain"}),"\n",(0,s.jsx)(t.li,{children:"Use for metadata and references"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(t.h3,{id:"data-size-considerations",children:"Data Size Considerations"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Consider data size limits\nconst MAX_DATA_SIZE = 1000000; // 1MB\n\nfunction validateDataSize(data: Uint8Array): boolean {\n    if (data.length > MAX_DATA_SIZE) {\n        throw new Error("Data too large for on-chain storage");\n    }\n    return true;\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"error-handling-1",children:"Error Handling"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Comprehensive error handling\nasync function storeDataSafely(data: Uint8Array) {\n    try {\n        // Validate data\n        if (data.length === 0) {\n            throw new Error("Data cannot be empty");\n        }\n        \n        // Check if already exists\n        const address = await dataPointStorage.calculateAddress(data);\n        const size = await dataPointStorage.dataPointSize(address);\n        \n        if (size > 0) {\n            console.log("Data already exists");\n            return address;\n        }\n        \n        // Store data\n        const tx = await dataPointStorage.writeDataPoint(data);\n        await tx.wait();\n        \n        return address;\n    } catch (error) {\n        console.error("Storage failed:", error);\n        throw error;\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"monitoring",children:"Monitoring"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// Monitor storage events\nconst filter = dataPointStorage.filters.DataPointWritten();\ndataPointStorage.on(filter, (dataPointAddress) => {\n    console.log("New data point stored:", dataPointAddress);\n});\n'})}),"\n",(0,s.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/docs/esp/registry",children:"Learn about Registry Operations"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/docs/esp/royalties",children:"Understand Royalty System"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/docs/esp/datapoints",children:"Explore Data Points"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/docs/esp/esp-overview",children:"Back to Overview"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>d});var n=a(6540);const s={},i=n.createContext(s);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);