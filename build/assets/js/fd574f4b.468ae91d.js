"use strict";(self.webpackChunkdip_docs=self.webpackChunkdip_docs||[]).push([[1149],{4e3:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"wttp/wttp-gateway","title":"WTTP Gateway","description":"The WTTP Gateway is a specialized smart contract designed to optimize content delivery from WTTP sites for off-chain applications. It provides a single-call interface that eliminates the need for multiple blockchain transactions when fetching content, especially large files stored across multiple data points.","source":"@site/docs/03-wttp/06-gateway.md","sourceDirName":"03-wttp","slug":"/wttp/wttp-gateway","permalink":"/docs/wttp/wttp-gateway","draft":false,"unlisted":false,"editUrl":"https://github.com/TechnicallyWeb3/dip-docs/tree/main/packages/create-docusaurus/templates/shared/docs/03-wttp/06-gateway.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"wttp-gateway","title":"WTTP Gateway"},"sidebar":"tutorialSidebar","previous":{"title":"WTTP Sites","permalink":"/docs/wttp/wttp-sites"},"next":{"title":"WTTP Deployment","permalink":"/docs/wttp/wttp-deployment"}}');var r=t(4848),a=t(8453);const i={id:"wttp-gateway",title:"WTTP Gateway"},o="WTTP Gateway - Optimized Content Delivery",l={},c=[{value:"What is WTTP Gateway?",id:"what-is-wttp-gateway",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Key Benefits",id:"key-benefits",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Content Verification",id:"content-verification",level:3},{value:"Developer Experience",id:"developer-experience",level:3},{value:"Gateway Methods",id:"gateway-methods",level:2},{value:"OPTIONS",id:"options",level:3},{value:"HEAD",id:"head",level:3},{value:"LOCATE (Enhanced)",id:"locate-enhanced",level:3},{value:"GET (Enhanced)",id:"get-enhanced",level:3},{value:"Range Request System",id:"range-request-system",level:2},{value:"Chunk Ranges",id:"chunk-ranges",level:3},{value:"Byte Ranges",id:"byte-ranges",level:3},{value:"Combined Ranges",id:"combined-ranges",level:3},{value:"Content Verification",id:"content-verification-1",level:2},{value:"Chunk Size Verification",id:"chunk-size-verification",level:3},{value:"Content Hash Verification",id:"content-hash-verification",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Using WTTP Handler (Recommended)",id:"using-wttp-handler-recommended",level:3},{value:"Using WTTP Gateway Directly",id:"using-wttp-gateway-directly",level:3},{value:"Streaming Large Files",id:"streaming-large-files",level:3},{value:"Media Streaming",id:"media-streaming",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Optimization",id:"performance-optimization-1",level:2},{value:"Caching Strategies",id:"caching-strategies",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Deployment and Configuration",id:"deployment-and-configuration",level:2},{value:"Using Public Gateways",id:"using-public-gateways",level:3},{value:"Deploying Custom Gateways",id:"deploying-custom-gateways",level:3},{value:"Gateway Configuration",id:"gateway-configuration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Appropriate Ranges",id:"1-use-appropriate-ranges",level:3},{value:"2. Implement Proper Error Handling",id:"2-implement-proper-error-handling",level:3},{value:"3. Use HEAD Requests for Metadata",id:"3-use-head-requests-for-metadata",level:3},{value:"4. Implement Content Verification",id:"4-implement-content-verification",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debugging Tools",id:"debugging-tools",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"wttp-gateway---optimized-content-delivery",children:"WTTP Gateway - Optimized Content Delivery"})}),"\n",(0,r.jsx)(n.p,{children:"The WTTP Gateway is a specialized smart contract designed to optimize content delivery from WTTP sites for off-chain applications. It provides a single-call interface that eliminates the need for multiple blockchain transactions when fetching content, especially large files stored across multiple data points."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\ud83d\udca1 For Most Developers"}),": Consider using the ",(0,r.jsx)(n.a,{href:"/docs/handler/handler-overview",children:"WTTP Handler"})," instead, which provides automatic contract selection, redirect handling, and a simplified API. The handler intelligently chooses between sites and gateway based on your needs."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"what-is-wttp-gateway",children:"What is WTTP Gateway?"}),"\n",(0,r.jsx)(n.p,{children:"The WTTP Gateway acts as an intermediary layer between off-chain applications and WTTP sites, providing:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Call Efficiency"}),": Fetch content with one blockchain call instead of N+1 calls"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advanced Range Requests"}),": Support for both chunk ranges and byte ranges"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Content Verification"}),": Built-in data integrity checking at the chunk level"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Assembly"}),": Seamlessly combines data from multiple ESP data points"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    Off-chain Application   \u2502  \u2190 Your dApp, website, or API\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n               \u2502\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     WTTP Gateway           \u2502  \u2190 Optimized content delivery\r\n\u2502  \u2022 Single blockchain call  \u2502\r\n\u2502  \u2022 Byte range processing   \u2502\r\n\u2502  \u2022 Data point assembly     \u2502\r\n\u2502  \u2022 Content verification    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n               \u2502\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     WTTP Sites             \u2502  \u2190 Multiple sites accessible\r\n\u2502  \u2022 Content management      \u2502\r\n\u2502  \u2022 Permission control      \u2502\r\n\u2502  \u2022 Metadata storage        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n               \u2502\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     ESP DataPointStorage   \u2502  \u2190 Raw content storage\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,r.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"N+1 Call Reduction"}),": Instead of calling the site (1 call) + each data point (N calls), the gateway does everything in a single call"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient Range Requests"}),": Fetch only the specific bytes you need from large files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Chunk Assembly"}),": Seamlessly combines data from multiple chunks"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"content-verification",children:"Content Verification"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Chunk-Level Validation"}),": Get exact sizes for each data point to verify content integrity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hash Verification"}),": Calculate and verify content hashes at the chunk level"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tamper Detection"}),": Ensure data hasn't been modified since upload"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"developer-experience",children:"Developer Experience"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplified Integration"}),": Easy-to-use interface for off-chain applications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Familiar HTTP Semantics"}),": Standard HTTP methods with blockchain benefits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Comprehensive Error Handling"}),": Clear error messages and status codes"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"gateway-methods",children:"Gateway Methods"}),"\n",(0,r.jsx)(n.h3,{id:"options",children:"OPTIONS"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Discover allowed methods and CORS policies",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Gas Cost"}),": Low (read-only)",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Returns"}),": ",(0,r.jsx)(n.code,{children:"OPTIONSResponse"})," with allowed methods"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const response = await gateway.OPTIONS(siteAddress, '/api/data');\r\nconsole.log(response.allow); // Bitmask of allowed methods\r\nconsole.log(response.status); // Response status\n"})}),"\n",(0,r.jsx)(n.h3,{id:"head",children:"HEAD"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Retrieve metadata without downloading content",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Gas Cost"}),": Low (read-only)",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Returns"}),": ",(0,r.jsx)(n.code,{children:"HEADResponse"})," with headers and metadata"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const headRequest: HEADRequest = {\r\n  path: '/index.html',\r\n  ifModifiedSince: 0,\r\n  ifNoneMatch: ethers.ZeroHash\r\n};\r\n\r\nconst response = await gateway.HEAD(siteAddress, headRequest);\r\nconsole.log(response.status);     // 200, 304, 404, etc.\r\nconsole.log(response.etag);       // Content hash for caching\r\nconsole.log(response.metadata);   // File metadata\n"})}),"\n",(0,r.jsx)(n.h3,{id:"locate-enhanced",children:"LOCATE (Enhanced)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Locate resources with detailed data point information",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Gas Cost"}),": Medium (reads from multiple contracts)",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Returns"}),": ",(0,r.jsx)(n.code,{children:"LOCATEResponseSecure"})," with data point sizes and structure"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const locateRequest: LOCATERequest = {\r\n  head: { \r\n    path: '/large-file.pdf',\r\n    ifModifiedSince: 0,\r\n    ifNoneMatch: ethers.ZeroHash\r\n  },\r\n  rangeChunks: { start: 0, end: 0 } // All chunks\r\n};\r\n\r\nconst response = await gateway.LOCATE(siteAddress, locateRequest);\r\nconsole.log(response.locate.resource.dataPoints); // Data point addresses\r\nconsole.log(response.structure.sizes);            // Individual chunk sizes\r\nconsole.log(response.structure.totalSize);        // Total file size\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Content Verification"}),": Get exact chunk sizes for hash verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Range Planning"}),": Understand file structure before making byte range requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Integrity"}),": Verify each chunk hasn't been tampered with"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"get-enhanced",children:"GET (Enhanced)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Retrieve content with optimized byte range support",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Gas Cost"}),": Medium to High (depends on content size and range)",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Returns"}),": ",(0,r.jsx)(n.code,{children:"GETResponse"})," with assembled content"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const getRequest: GETRequest = {\r\n  locate: {\r\n    head: { \r\n      path: '/large-file.pdf',\r\n      ifModifiedSince: 0,\r\n      ifNoneMatch: ethers.ZeroHash\r\n    },\r\n    rangeChunks: { start: 0, end: 0 } // All chunks\r\n  },\r\n  rangeBytes: { start: 1024, end: 2047 } // Specific byte range\r\n};\r\n\r\nconst response = await gateway.GET(siteAddress, getRequest);\r\nconsole.log(response.head.status);     // 200, 206, 404, etc.\r\nconsole.log(response.body.data);       // Requested byte range\r\nconsole.log(response.body.sizes);      // Data point size information\n"})}),"\n",(0,r.jsx)(n.h2,{id:"range-request-system",children:"Range Request System"}),"\n",(0,r.jsx)(n.p,{children:"The gateway supports two types of ranges for maximum flexibility:"}),"\n",(0,r.jsx)(n.h3,{id:"chunk-ranges",children:"Chunk Ranges"}),"\n",(0,r.jsx)(n.p,{children:"Select which data points to fetch:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Fetch chunks 2-4 (zero-indexed)\r\nconst chunkRange = { start: 2, end: 4 };\r\n\r\n// Fetch all chunks\r\nconst allChunks = { start: 0, end: 0 };\r\n\r\n// Fetch last 3 chunks (if you know total count)\r\nconst lastChunks = { start: -3, end: -1 };\n"})}),"\n",(0,r.jsx)(n.h3,{id:"byte-ranges",children:"Byte Ranges"}),"\n",(0,r.jsx)(n.p,{children:"Select specific bytes within the content:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Fetch bytes 1024-2047\r\nconst byteRange = { start: 1024, end: 2047 };\r\n\r\n// Fetch first 1KB\r\nconst firstKB = { start: 0, end: 1023 };\r\n\r\n// Fetch last 512 bytes\r\nconst lastBytes = { start: -512, end: -1 };\r\n\r\n// Fetch single byte\r\nconst singleByte = { start: 100, end: 100 };\n"})}),"\n",(0,r.jsx)(n.h3,{id:"combined-ranges",children:"Combined Ranges"}),"\n",(0,r.jsx)(n.p,{children:"Use both chunk and byte ranges for maximum efficiency:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const getRequest: GETRequest = {\r\n  locate: {\r\n    head: { path: '/large-file.pdf' },\r\n    rangeChunks: { start: 1, end: 3 } // Only chunks 1-3\r\n  },\r\n  rangeBytes: { start: 500, end: 1500 } // Bytes 500-1500 within those chunks\r\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"content-verification-1",children:"Content Verification"}),"\n",(0,r.jsx)(n.p,{children:"The gateway provides built-in content verification capabilities:"}),"\n",(0,r.jsx)(n.h3,{id:"chunk-size-verification",children:"Chunk Size Verification"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const response = await gateway.LOCATE(siteAddress, locateRequest);\r\nconst expectedSizes = [1024, 1024, 512]; // Expected chunk sizes\r\nconst actualSizes = response.structure.sizes;\r\n\r\n// Verify each chunk size\r\nfor (let i = 0; i < expectedSizes.length; i++) {\r\n  if (actualSizes[i] !== expectedSizes[i]) {\r\n    throw new Error(`Chunk ${i} size mismatch`);\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"content-hash-verification",children:"Content Hash Verification"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Get content and verify hash\r\nconst response = await gateway.GET(siteAddress, getRequest);\r\nconst content = response.body.data;\r\nconst actualHash = ethers.keccak256(content);\r\nconst expectedHash = response.head.etag;\r\n\r\nif (actualHash !== expectedHash) {\r\n  throw new Error('Content hash mismatch');\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"using-wttp-handler-recommended",children:"Using WTTP Handler (Recommended)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { WTTPHandler } from '@wttp/handler';\r\n\r\n// Initialize handler (automatically selects best contract)\r\nconst handler = new WTTPHandler({\r\n  provider: ethers.provider,\r\n  gateway: GATEWAY_ADDRESS, // Optional\r\n  site: SITE_ADDRESS        // Optional\r\n});\r\n\r\n// Fetch content (handler manages everything)\r\nconst content = await handler.fetch('/index.html');\r\nconsole.log(content);\r\n\r\n// Fetch with range request\r\nconst partialContent = await handler.fetch('/large-file.pdf', {\r\n  range: { start: 0, end: 1023 }\r\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-wttp-gateway-directly",children:"Using WTTP Gateway Directly"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { WTTPGateway } from '@wttp/gateway';\r\n\r\n// Connect to gateway\r\nconst gateway = new ethers.Contract(\r\n  GATEWAY_ADDRESS,\r\n  WTTPGateway.abi,\r\n  provider\r\n);\r\n\r\n// Fetch entire file\r\nconst response = await gateway.GET(siteAddress, {\r\n  locate: {\r\n    head: { path: '/index.html' },\r\n    rangeChunks: { start: 0, end: 0 }\r\n  },\r\n  rangeBytes: { start: 0, end: 0 }\r\n});\r\n\r\nconst content = ethers.toUtf8String(response.body.data);\r\nconsole.log(content);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"streaming-large-files",children:"Streaming Large Files"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function streamLargeFile(siteAddress: string, path: string, chunkSize: number = 1024) {\r\n  // First, get file info\r\n  const locateResponse = await gateway.LOCATE(siteAddress, {\r\n    head: { path },\r\n    rangeChunks: { start: 0, end: 0 }\r\n  });\r\n  \r\n  const totalSize = Number(locateResponse.structure.totalSize);\r\n  const chunks = [];\r\n  \r\n  // Stream in chunks\r\n  for (let offset = 0; offset < totalSize; offset += chunkSize) {\r\n    const end = Math.min(offset + chunkSize - 1, totalSize - 1);\r\n    \r\n    const response = await gateway.GET(siteAddress, {\r\n      locate: {\r\n        head: { path },\r\n        rangeChunks: { start: 0, end: 0 }\r\n      },\r\n      rangeBytes: { start: offset, end }\r\n    });\r\n    \r\n    chunks.push(response.body.data);\r\n  }\r\n  \r\n  return Buffer.concat(chunks);\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"media-streaming",children:"Media Streaming"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function streamVideo(siteAddress: string, videoPath: string, startTime: number) {\r\n  // Calculate byte offset based on time (assuming 1MB per second)\r\n  const bytesPerSecond = 1024 * 1024;\r\n  const startByte = startTime * bytesPerSecond;\r\n  const endByte = startByte + (10 * bytesPerSecond); // 10 seconds\r\n  \r\n  const response = await gateway.GET(siteAddress, {\r\n    locate: {\r\n      head: { path: videoPath },\r\n      rangeChunks: { start: 0, end: 0 }\r\n    },\r\n    rangeBytes: { start: startByte, end: endByte }\r\n  });\r\n  \r\n  return response.body.data;\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.p,{children:"The gateway provides comprehensive error handling:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"try {\r\n  const response = await gateway.GET(siteAddress, getRequest);\r\n  \r\n  switch (response.head.status) {\r\n    case 200:\r\n      console.log('Success - full content');\r\n      break;\r\n    case 206:\r\n      console.log('Success - partial content');\r\n      break;\r\n    case 404:\r\n      console.log('Resource not found');\r\n      break;\r\n    case 403:\r\n      console.log('Access denied');\r\n      break;\r\n    case 405:\r\n      console.log('Method not allowed');\r\n      break;\r\n    default:\r\n      console.log('Unexpected status:', response.head.status);\r\n  }\r\n} catch (error) {\r\n  if (error.message.includes('Method Not Allowed')) {\r\n    console.log('LOCATE method not allowed for this resource');\r\n  } else if (error.message.includes('Out of Bounds')) {\r\n    console.log('Range request exceeds file bounds');\r\n  } else {\r\n    console.error('Gateway error:', error);\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization-1",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Use HEAD requests to check for updates\r\nconst headResponse = await gateway.HEAD(siteAddress, {\r\n  path: '/api/data',\r\n  ifNoneMatch: cachedETag\r\n});\r\n\r\nif (headResponse.status === 304) {\r\n  // Use cached content\r\n  return cachedContent;\r\n} else {\r\n  // Fetch updated content\r\n  const response = await gateway.GET(siteAddress, getRequest);\r\n  return response.body.data;\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Fetch multiple resources efficiently\r\nasync function fetchMultipleResources(siteAddress: string, paths: string[]) {\r\n  const promises = paths.map(path => \r\n    gateway.GET(siteAddress, {\r\n      locate: { head: { path }, rangeChunks: { start: 0, end: 0 } },\r\n      rangeBytes: { start: 0, end: 0 }\r\n    })\r\n  );\r\n  \r\n  return Promise.all(promises);\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"deployment-and-configuration",children:"Deployment and Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"using-public-gateways",children:"Using Public Gateways"}),"\n",(0,r.jsx)(n.p,{children:"Most networks have public gateways deployed:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Sepolia testnet\r\nconst SEPOLIA_GATEWAY = "0x1234...";\r\n\r\n// Polygon mainnet\r\nconst POLYGON_GATEWAY = "0x5678...";\r\n\r\n// Connect to public gateway\r\nconst gateway = new ethers.Contract(\r\n  SEPOLIA_GATEWAY,\r\n  WTTPGateway.abi,\r\n  provider\r\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"deploying-custom-gateways",children:"Deploying Custom Gateways"}),"\n",(0,r.jsx)(n.p,{children:"For advanced use cases, deploy your own gateway:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Deploy simple gateway\r\nnpx hardhat deploy:simple --network sepolia\r\n\r\n# Deploy with vanity address\r\nnpx hardhat deploy:vanity --network sepolia\r\n\r\n# Deploy with ignition\r\nnpx hardhat deploy:ignition --network sepolia\n"})}),"\n",(0,r.jsx)(n.h3,{id:"gateway-configuration",children:"Gateway Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Custom gateways can be configured for specific use cases:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Deploy gateway with custom access controls\r\nconst customGateway = await CustomGateway.deploy(\r\n  owner.address,\r\n  allowedSites, // Whitelist of allowed sites\r\n  maxFileSize,  // Maximum file size limit\r\n  rateLimits    // Rate limiting configuration\r\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-use-appropriate-ranges",children:"1. Use Appropriate Ranges"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Good: Use byte ranges for large files\r\nconst response = await gateway.GET(siteAddress, {\r\n  locate: { head: { path: '/large-file.pdf' }, rangeChunks: { start: 0, end: 0 } },\r\n  rangeBytes: { start: 0, end: 1023 } // First 1KB\r\n});\r\n\r\n// Avoid: Fetching entire large file when you only need a small portion\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-implement-proper-error-handling",children:"2. Implement Proper Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"try {\r\n  const response = await gateway.GET(siteAddress, getRequest);\r\n  // Process response\r\n} catch (error) {\r\n  // Handle specific error types\r\n  if (error.message.includes('Method Not Allowed')) {\r\n    // Handle permission errors\r\n  } else if (error.message.includes('Out of Bounds')) {\r\n    // Handle range errors\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-use-head-requests-for-metadata",children:"3. Use HEAD Requests for Metadata"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Check if content exists and get metadata\r\nconst headResponse = await gateway.HEAD(siteAddress, { path: '/api/data' });\r\nif (headResponse.status === 200) {\r\n  // Content exists, proceed with GET\r\n  const response = await gateway.GET(siteAddress, getRequest);\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-implement-content-verification",children:"4. Implement Content Verification"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Verify content integrity\r\nconst response = await gateway.GET(siteAddress, getRequest);\r\nconst expectedHash = response.head.etag;\r\nconst actualHash = ethers.keccak256(response.body.data);\r\n\r\nif (expectedHash !== actualHash) {\r\n  throw new Error('Content verification failed');\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Method Not Allowed"}),": The site doesn't allow LOCATE method for the resource"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check site permissions and CORS configuration"}),"\n",(0,r.jsx)(n.li,{children:"Use OPTIONS to discover allowed methods"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Out of Bounds"}),": Range request exceeds file bounds"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use LOCATE to get file size before making range requests"}),"\n",(0,r.jsx)(n.li,{children:"Validate range parameters before calling GET"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gas Limit Exceeded"}),": Requesting too much data in one call"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use smaller byte ranges"}),"\n",(0,r.jsx)(n.li,{children:"Implement chunked fetching for very large files"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Content Verification Failed"}),": Hash mismatch"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check if content was modified after upload"}),"\n",(0,r.jsx)(n.li,{children:"Verify you're using the correct hash algorithm"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"debugging-tools",children:"Debugging Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Enable debug logging\r\nconst DEBUG = true;\r\n\r\nif (DEBUG) {\r\n  console.log('Gateway address:', gateway.address);\r\n  console.log('Site address:', siteAddress);\r\n  console.log('Request:', getRequest);\r\n  console.log('Response status:', response.head.status);\r\n  console.log('Data length:', response.body.data.length);\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/handler/handler-overview",children:"Handler Documentation"})," - ",(0,r.jsx)(n.strong,{children:"Recommended"}),": Start with the WTTP Handler"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/wttp/wttp-methods.md",children:"Methods Documentation"})," - Complete HTTP methods reference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/wttp/wttp-permissions.md",children:"Permissions Guide"})," - Understanding access control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/wttp/wttp-sites.md",children:"Site Management"})," - Managing WTTP sites"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/esp/esp-overview",children:"ESP Overview"})," - Learn about the Ethereum Storage Protocol"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);