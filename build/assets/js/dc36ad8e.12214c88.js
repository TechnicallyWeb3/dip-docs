"use strict";(self.webpackChunkdip_docs=self.webpackChunkdip_docs||[]).push([[5397],{1794:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"esp/datapoints","title":"DataPoints","description":"Data points are the fundamental unit of storage in the Ethereum Storage Protocol (ESP). They provide immutable, content-addressed storage with unique identifiers based on the data content itself.","source":"@site/docs/02-esp/02-datapoints.md","sourceDirName":"02-esp","slug":"/esp/datapoints","permalink":"/docs/esp/datapoints","draft":false,"unlisted":false,"editUrl":"https://github.com/TechnicallyWeb3/dip-docs/tree/main/packages/create-docusaurus/templates/shared/docs/02-esp/02-datapoints.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"datapoints","title":"DataPoints"},"sidebar":"tutorialSidebar","previous":{"title":"ESP Overview","permalink":"/docs/esp/esp-overview"},"next":{"title":"ESP Storage","permalink":"/docs/esp/esp-storage"}}');var i=a(4848),s=a(8453);const r={id:"datapoints",title:"DataPoints"},d="DataPoints",o={},l=[{value:"What are Data Points?",id:"what-are-data-points",level:2},{value:"Key Characteristics",id:"key-characteristics",level:2},{value:"Content Addressing",id:"content-addressing",level:3},{value:"Data Size Limits",id:"data-size-limits",level:3},{value:"Immutability",id:"immutability",level:3},{value:"Uniqueness",id:"uniqueness",level:3},{value:"How Data Point Addresses Work",id:"how-data-point-addresses-work",level:2},{value:"Address Calculation",id:"address-calculation",level:3},{value:"Version System",id:"version-system",level:3},{value:"Example Address Calculation",id:"example-address-calculation",level:3},{value:"Data Point Lifecycle",id:"data-point-lifecycle",level:2},{value:"1. Creation",id:"1-creation",level:3},{value:"2. Storage",id:"2-storage",level:3},{value:"3. Registration (with royalties)",id:"3-registration-with-royalties",level:3},{value:"4. Retrieval",id:"4-retrieval",level:3},{value:"Data Point Operations",id:"data-point-operations",level:2},{value:"Storing Data",id:"storing-data",level:3},{value:"Reading Data",id:"reading-data",level:3},{value:"Address Verification",id:"address-verification",level:3},{value:"Data Types and Examples",id:"data-types-and-examples",level:2},{value:"Text Data",id:"text-data",level:3},{value:"JSON Data",id:"json-data",level:3},{value:"Binary Data",id:"binary-data",level:3},{value:"Smart Contract Data",id:"smart-contract-data",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Data Preparation",id:"data-preparation",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Gas Optimization",id:"gas-optimization",level:3},{value:"Data Validation",id:"data-validation",level:3},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Content Publishing",id:"content-publishing",level:3},{value:"Configuration Storage",id:"configuration-storage",level:3},{value:"Data References",id:"data-references",level:3},{value:"Handling Large Data",id:"handling-large-data",level:3},{value:"1. Bytes32 Array Pattern",id:"1-bytes32-array-pattern",level:4},{value:"2. Client-Side Chunking",id:"2-client-side-chunking",level:4},{value:"3. Example Implementation",id:"3-example-implementation",level:4},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Data Already Exists",id:"data-already-exists",level:4},{value:"Invalid Data",id:"invalid-data",level:4},{value:"Gas Estimation",id:"gas-estimation",level:4},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"datapoints",children:"DataPoints"})}),"\n",(0,i.jsx)(t.p,{children:"Data points are the fundamental unit of storage in the Ethereum Storage Protocol (ESP). They provide immutable, content-addressed storage with unique identifiers based on the data content itself."}),"\n",(0,i.jsx)(t.h2,{id:"what-are-data-points",children:"What are Data Points?"}),"\n",(0,i.jsx)(t.p,{children:"A data point is any piece of data that can be stored in the ESP system. It can be:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Text content (articles, documentation, configuration)"}),"\n",(0,i.jsx)(t.li,{children:"Binary data (images, videos, files)"}),"\n",(0,i.jsx)(t.li,{children:"Structured data (JSON, XML, CSV)"}),"\n",(0,i.jsx)(t.li,{children:"Smart contract data (ABIs, bytecode)"}),"\n",(0,i.jsx)(t.li,{children:"Any arbitrary bytes"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,i.jsx)(t.h3,{id:"content-addressing",children:"Content Addressing"}),"\n",(0,i.jsx)(t.p,{children:"Data points are identified by their content, not by a location or ID assigned by the system. This means:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Same data always produces the same address"}),"\n",(0,i.jsx)(t.li,{children:"Different data produces different addresses"}),"\n",(0,i.jsx)(t.li,{children:"Data integrity is cryptographically guaranteed"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"data-size-limits",children:"Data Size Limits"}),"\n",(0,i.jsx)(t.p,{children:"ESP has practical limits on data point size:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Recommended maximum"}),": 32KB per data point"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Absolute maximum"}),": ~42KB (tested limit)"]}),"\n",(0,i.jsx)(t.li,{children:"For larger data, build custom smart contracts that chunk data into ESP-compatible sizes"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"immutability",children:"Immutability"}),"\n",(0,i.jsx)(t.p,{children:"Once stored, data points cannot be:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Modified"}),"\n",(0,i.jsx)(t.li,{children:"Deleted"}),"\n",(0,i.jsx)(t.li,{children:"Corrupted (without detection)"}),"\n",(0,i.jsx)(t.li,{children:"Replaced with different data"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"uniqueness",children:"Uniqueness"}),"\n",(0,i.jsx)(t.p,{children:"Each unique piece of data gets a unique address:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Duplicate data shares the same address"}),"\n",(0,i.jsx)(t.li,{children:"No two different data pieces can have the same address"}),"\n",(0,i.jsx)(t.li,{children:"Collision-resistant through cryptographic hashing"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"how-data-point-addresses-work",children:"How Data Point Addresses Work"}),"\n",(0,i.jsx)(t.h3,{id:"address-calculation",children:"Address Calculation"}),"\n",(0,i.jsx)(t.p,{children:"Data point addresses are calculated using:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-solidity",children:"function calculateDataPointAddress(\n    bytes memory _data,\n    uint8 _version\n) pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_data, _version));\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"version-system",children:"Version System"}),"\n",(0,i.jsx)(t.p,{children:"ESP uses a version system to handle protocol updates:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Current version: 2"}),"\n",(0,i.jsx)(t.li,{children:"Version is included in address calculation"}),"\n",(0,i.jsx)(t.li,{children:"Allows for protocol evolution while maintaining backward compatibility"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"example-address-calculation",children:"Example Address Calculation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'import { ethers } from \'ethers\';\n\n// Calculate address for text data\nconst data = ethers.toUtf8Bytes("Hello, ESP!");\nconst version = 2;\nconst address = ethers.keccak256(ethers.solidityPacked(["bytes", "uint8"], [data, version]));\n\nconsole.log("Data Point Address:", address);\n// Output: 0x1234... (unique hash based on content and version)\n'})}),"\n",(0,i.jsx)(t.h2,{id:"data-point-lifecycle",children:"Data Point Lifecycle"}),"\n",(0,i.jsx)(t.h3,{id:"1-creation",children:"1. Creation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Prepare data\nconst data = ethers.toUtf8Bytes("My important data");\n\n// Calculate address (optional, for verification)\nconst address = await dataPointStorage.calculateAddress(data);\nconsole.log("Will be stored at:", address);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"2-storage",children:"2. Storage"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Store data point\nconst tx = await dataPointStorage.writeDataPoint(data);\nawait tx.wait();\n\n// Get the actual address where it was stored\nconst storedAddress = await tx.getAddress();\n"})}),"\n",(0,i.jsx)(t.h3,{id:"3-registration-with-royalties",children:"3. Registration (with royalties)"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"// Register with publisher for royalty collection\nconst tx = await dataPointRegistry.registerDataPoint(data, publisherAddress);\nawait tx.wait();\n"})}),"\n",(0,i.jsx)(t.h3,{id:"4-retrieval",children:"4. Retrieval"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Read data point\nconst retrievedData = await dataPointStorage.readDataPoint(address);\nconsole.log("Retrieved data:", ethers.toUtf8String(retrievedData));\n'})}),"\n",(0,i.jsx)(t.h2,{id:"data-point-operations",children:"Data Point Operations"}),"\n",(0,i.jsx)(t.h3,{id:"storing-data",children:"Storing Data"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Basic storage\nconst data = ethers.toUtf8Bytes("Hello, World!");\nconst tx = await dataPointStorage.writeDataPoint(data);\nawait tx.wait();\n\n// With royalty registration\nconst tx2 = await dataPointRegistry.registerDataPoint(data, signer.address);\nawait tx2.wait();\n'})}),"\n",(0,i.jsx)(t.h3,{id:"reading-data",children:"Reading Data"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Read by address\nconst data = await dataPointStorage.readDataPoint(address);\n\n// Check if data exists\nconst size = await dataPointStorage.dataPointSize(address);\nif (size > 0) {\n    console.log("Data exists, size:", size);\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"address-verification",children:"Address Verification"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Calculate expected address\nconst expectedAddress = await dataPointStorage.calculateAddress(data);\n\n// Verify data integrity\nconst storedData = await dataPointStorage.readDataPoint(expectedAddress);\nconst isIntact = ethers.keccak256(storedData) === ethers.keccak256(data);\nconsole.log("Data integrity:", isIntact);\n'})}),"\n",(0,i.jsx)(t.h2,{id:"data-types-and-examples",children:"Data Types and Examples"}),"\n",(0,i.jsx)(t.h3,{id:"text-data",children:"Text Data"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Store text content\nconst article = "This is a sample article about ESP...";\nconst data = ethers.toUtf8Bytes(article);\nconst tx = await dataPointRegistry.registerDataPoint(data, publisherAddress);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"json-data",children:"JSON Data"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Store structured data\nconst config = {\n    name: "My App",\n    version: "1.0.0",\n    settings: { theme: "dark" }\n};\nconst data = ethers.toUtf8Bytes(JSON.stringify(config));\nconst tx = await dataPointRegistry.registerDataPoint(data, publisherAddress);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"binary-data",children:"Binary Data"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Store binary data (e.g., image)\nconst imageData = "0x89504e470d0a1a0a..."; // PNG file bytes\nconst data = ethers.getBytes(imageData);\nconst tx = await dataPointRegistry.registerDataPoint(data, publisherAddress);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"smart-contract-data",children:"Smart Contract Data"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Store contract ABI\nconst abi = [\n    {\n        "inputs": [{"name": "value", "type": "uint256"}],\n        "name": "setValue",\n        "outputs": [],\n        "type": "function"\n    }\n];\nconst data = ethers.toUtf8Bytes(JSON.stringify(abi));\nconst tx = await dataPointRegistry.registerDataPoint(data, publisherAddress);\n'})}),"\n",(0,i.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(t.h3,{id:"data-preparation",children:"Data Preparation"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Ensure data is in the correct format before storage"}),"\n",(0,i.jsx)(t.li,{children:"Consider data compression for large files"}),"\n",(0,i.jsx)(t.li,{children:"Validate data integrity before storing"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'try {\n    const tx = await dataPointStorage.writeDataPoint(data);\n    await tx.wait();\n    console.log("Data stored successfully");\n} catch (error) {\n    if (error.message.includes("DataExists")) {\n        console.log("Data already exists at this address");\n    } else if (error.message.includes("InvalidData")) {\n        console.log("Invalid data provided");\n    } else {\n        console.error("Storage failed:", error);\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"gas-optimization",children:"Gas Optimization"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Batch multiple data points in a single transaction when possible"}),"\n",(0,i.jsx)(t.li,{children:"Consider data size impact on gas costs"}),"\n",(0,i.jsx)(t.li,{children:"Use appropriate gas limits for large data"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"data-validation",children:"Data Validation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Validate data before storage\nfunction validateData(data: Uint8Array): boolean {\n    if (data.length === 0) {\n        throw new Error("Data cannot be empty");\n    }\n    if (data.length > 32768) { // 32KB recommended limit\n        throw new Error("Data exceeds recommended 32KB limit");\n    }\n    if (data.length > 43008) { // ~42KB absolute limit\n        throw new Error("Data exceeds absolute 42KB limit");\n    }\n    return true;\n}\n\n// Use validation\nvalidateData(data);\nconst tx = await dataPointStorage.writeDataPoint(data);\n'})}),"\n",(0,i.jsx)(t.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,i.jsx)(t.h3,{id:"content-publishing",children:"Content Publishing"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Publish an article\nconst article = {\n    title: "Understanding ESP",\n    content: "ESP is a decentralized storage protocol...",\n    author: "0x1234...",\n    timestamp: Date.now()\n};\nconst data = ethers.toUtf8Bytes(JSON.stringify(article));\nconst tx = await dataPointRegistry.registerDataPoint(data, authorAddress);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"configuration-storage",children:"Configuration Storage"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Store application configuration\nconst config = {\n    network: "mainnet",\n    rpcUrl: "https://eth-mainnet.alchemyapi.io/v2/...",\n    contractAddresses: {\n        token: "0x1234...",\n        nft: "0x5678..."\n    }\n};\nconst data = ethers.toUtf8Bytes(JSON.stringify(config));\nconst tx = await dataPointRegistry.registerDataPoint(data, deployerAddress);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"data-references",children:"Data References"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Create reference to external data\nconst reference = {\n    type: "ipfs",\n    hash: "QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco",\n    metadata: {\n        name: "document.pdf",\n        size: 1024000,\n        mimeType: "application/pdf"\n    }\n};\nconst data = ethers.toUtf8Bytes(JSON.stringify(reference));\nconst tx = await dataPointRegistry.registerDataPoint(data, publisherAddress);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"handling-large-data",children:"Handling Large Data"}),"\n",(0,i.jsx)(t.p,{children:"For data larger than 32KB, you'll need to build custom smart contracts that work with ESP. Here are some patterns to consider:"}),"\n",(0,i.jsx)(t.h4,{id:"1-bytes32-array-pattern",children:"1. Bytes32 Array Pattern"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-solidity",children:'// Custom contract for storing large files as chunks\ncontract LargeFileStorage {\n    IDataPointRegistry public registry;\n    \n    struct LargeFile {\n        bytes32[] chunks;  // Array of ESP data point addresses\n        uint256 totalSize;\n        string metadata;\n    }\n    \n    mapping(bytes32 => LargeFile) public files;\n    \n    function storeLargeFile(\n        bytes[] memory dataChunks,\n        string memory metadata\n    ) external returns (bytes32 fileId) {\n        bytes32[] memory chunkAddresses = new bytes32[](dataChunks.length);\n        uint256 totalSize = 0;\n        \n        // Store each chunk in ESP\n        for (uint i = 0; i < dataChunks.length; i++) {\n            require(dataChunks[i].length <= 32768, "Chunk too large");\n            \n            bytes32 chunkAddress = registry.registerDataPoint(dataChunks[i], msg.sender);\n            chunkAddresses[i] = chunkAddress;\n            totalSize += dataChunks[i].length;\n        }\n        \n        fileId = keccak256(abi.encodePacked(chunkAddresses, block.timestamp));\n        \n        files[fileId] = LargeFile({\n            chunks: chunkAddresses,\n            totalSize: totalSize,\n            metadata: metadata\n        });\n    }\n    \n    function retrieveLargeFile(bytes32 fileId) external view returns (bytes memory) {\n        LargeFile memory file = files[fileId];\n        bytes memory fullData = new bytes(file.totalSize);\n        uint256 offset = 0;\n        \n        for (uint i = 0; i < file.chunks.length; i++) {\n            bytes memory chunk = registry.DPS().readDataPoint(file.chunks[i]);\n            for (uint j = 0; j < chunk.length; j++) {\n                fullData[offset + j] = chunk[j];\n            }\n            offset += chunk.length;\n        }\n        \n        return fullData;\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h4,{id:"2-client-side-chunking",children:"2. Client-Side Chunking"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Split large data into ESP-compatible chunks\nfunction chunkData(data: Uint8Array, chunkSize: number = 30000): Uint8Array[] {\n    const chunks: Uint8Array[] = [];\n    for (let i = 0; i < data.length; i += chunkSize) {\n        chunks.push(data.slice(i, i + chunkSize));\n    }\n    return chunks;\n}\n\n// Store chunks and create metadata\nasync function storeLargeFile(data: Uint8Array, publisherAddress: string) {\n    const chunks = chunkData(data);\n    const chunkAddresses = [];\n    \n    // Store each chunk in ESP\n    for (const chunk of chunks) {\n        const tx = await dataPointRegistry.registerDataPoint(chunk, publisherAddress);\n        await tx.wait();\n        const address = await dataPointStorage.calculateAddress(chunk);\n        chunkAddresses.push(address);\n    }\n    \n    // Create metadata with chunk references\n    const metadata = {\n        type: "chunked-file",\n        chunks: chunkAddresses,\n        totalSize: data.length,\n        chunkCount: chunks.length,\n        checksum: ethers.keccak256(data)\n    };\n    \n    const metadataData = ethers.toUtf8Bytes(JSON.stringify(metadata));\n    const metadataTx = await dataPointRegistry.registerDataPoint(metadataData, publisherAddress);\n    await metadataTx.wait();\n    \n    return await dataPointStorage.calculateAddress(metadataData);\n}\n'})}),"\n",(0,i.jsx)(t.h4,{id:"3-example-implementation",children:"3. Example Implementation"}),"\n",(0,i.jsxs)(t.p,{children:["For reference: ",(0,i.jsx)(t.a,{href:"/docs/wttp/wttp-storage",children:"WTTP Storage"})," uses an array-based chunking strategy that you can adapt for your needs. ",(0,i.jsx)(t.a,{href:"/docs/wttp/wttp-storage",children:"WTTP Gateway"})," reads from the array using memory access for reading large files."]}),"\n",(0,i.jsx)(t.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(t.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,i.jsx)(t.h4,{id:"data-already-exists",children:"Data Already Exists"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Check if data exists before storing\nconst address = await dataPointStorage.calculateAddress(data);\nconst size = await dataPointStorage.dataPointSize(address);\n\nif (size > 0) {\n    console.log("Data already exists at:", address);\n    // Use existing data or handle accordingly\n} else {\n    // Safe to store\n    const tx = await dataPointStorage.writeDataPoint(data);\n}\n'})}),"\n",(0,i.jsx)(t.h4,{id:"invalid-data",children:"Invalid Data"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Validate data before storage\nif (data.length === 0) {\n    throw new Error("Cannot store empty data");\n}\n'})}),"\n",(0,i.jsx)(t.h4,{id:"gas-estimation",children:"Gas Estimation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'// Estimate gas before transaction\nconst gasEstimate = await dataPointStorage.writeDataPoint.estimateGas(data);\nconsole.log("Estimated gas:", gasEstimate.toString());\n\n// Use gas estimate with buffer\nconst tx = await dataPointStorage.writeDataPoint(data, {\n    gasLimit: gasEstimate.mul(120).div(100) // 20% buffer\n});\n'})}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/esp/esp-storage",children:"Learn about Storage Layer"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/esp/registry",children:"Explore Registry Operations"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/esp/royalties",children:"Understand Royalty System"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/docs/esp/esp-overview",children:"Back to Overview"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>d});var n=a(6540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);